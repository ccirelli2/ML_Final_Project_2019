df_x              <- X.data[[i]]
df_y              <- Y.data[[i]]
# Train MLR
m0                = glmnet(s1_x, s1_y, alpha = num.alpha, lambda = grid, standardize = TRUE)
# Get Best Lambda
m0.min.lambda     = m0$lambda.min
# Fit Best Model
m0.best.fit       = glmnet(s1_x, s1_y, alpha = num.alpha, m0.min.lambda, standardize = TRUE)
# Generate Prediction & Calculate RSE
y_hat             = predict(m0.best.fit, df_x)
m0.rse            = sqrt(sum((df_y - y_hat)^2) / (length(df_y) - 2))
# Append RSE to ridge.rse list
ridge.rse.test[i] = m0.rse
}
for (i in seq(1, length(names.datasets))){
ridge_cv(i, X.datasets, Y.datasets, 0, grid)
}
# Define Function Get Test RSE
ridge_cv <- function(i, X.data, Y.data, num.alpha, grid){
# Create DataFrame Objects
df_x              <- X.data[[i]]
df_y              <- Y.data[[i]]
print(df_y)
# Train MLR
m0                = glmnet(s1_x, s1_y, alpha = num.alpha, lambda = grid, standardize = TRUE)
# Get Best Lambda
m0.min.lambda     = m0$lambda.min
# Fit Best Model
m0.best.fit       = glmnet(s1_x, s1_y, alpha = num.alpha, m0.min.lambda, standardize = TRUE)
# Generate Prediction & Calculate RSE
y_hat             = predict(m0.best.fit, df_x)
m0.rse            = sqrt(sum((df_y - y_hat)^2) / (length(df_y) - 2))
# Append RSE to ridge.rse list
ridge.rse.test[i] = m0.rse
}
for (i in seq(1, length(names.datasets))){
ridge_cv(i, X.datasets, Y.datasets, 0, grid)
}
ridge_cv <- function(i, X.data, Y.data, num.alpha, grid){
# Create DataFrame Objects
df_x              <- X.data[i]
df_y              <- Y.data[i]
print(df_y)
# Train MLR
m0                = glmnet(s1_x, s1_y, alpha = num.alpha, lambda = grid, standardize = TRUE)
# Get Best Lambda
m0.min.lambda     = m0$lambda.min
# Fit Best Model
m0.best.fit       = glmnet(s1_x, s1_y, alpha = num.alpha, m0.min.lambda, standardize = TRUE)
# Generate Prediction & Calculate RSE
y_hat             = predict(m0.best.fit, df_x)
m0.rse            = sqrt(sum((df_y - y_hat)^2) / (length(df_y) - 2))
# Append RSE to ridge.rse list
ridge.rse.test[i] = m0.rse
}
for (i in seq(1, length(names.datasets))){
ridge_cv(i, X.datasets, Y.datasets, 0, grid)
}
s1_x
ridge_cv <- function(i, X.data, Y.data, num.alpha, grid){
# Create DataFrame Objects
df_x              <- X.data[i]
df_y              <- Y.data[i]
print(df_x)
# Train MLR
m0                = glmnet(s1_x, s1_y, alpha = num.alpha, lambda = grid, standardize = TRUE)
# Get Best Lambda
m0.min.lambda     = m0$lambda.min
# Fit Best Model
m0.best.fit       = glmnet(s1_x, s1_y, alpha = num.alpha, m0.min.lambda, standardize = TRUE)
# Generate Prediction & Calculate RSE
y_hat             = predict(m0.best.fit, df_x)
m0.rse            = sqrt(sum((df_y - y_hat)^2) / (length(df_y) - 2))
# Append RSE to ridge.rse list
ridge.rse.test[i] = m0.rse
}
for (i in seq(1, length(names.datasets))){
ridge_cv(i, X.datasets, Y.datasets, 0, grid)
}
X.datasets     = c(s1_x, s2_x, s3_x, s4_x, s5_x, s6_x)
Y.datasets     = c(s1_y, s2_y, s3_y, s4_y, s5_y, s6_y)
names.datasets = c('s1', 's2', 's3', 's4', 's5', 's6')
X.datasets[i]
X.datasets[[i]]
X.datasets
typeof(s1_x)
s1_x
type(s1_x)
class(s1_x)
length(X.datasets)
X.datasets     = list(s1_x, s2_x, s3_x, s4_x, s5_x, s6_x)
length(X.datasets)
Y.datasets     = list(s1_y, s2_y, s3_y, s4_y, s5_y, s6_y)
names.datasets = c('s1', 's2', 's3', 's4', 's5', 's6')
ridge_cv <- function(i, X.datasets, Y.datasets, num.alpha, grid){
# Create DataFrame Objects
df_x              <- X.data[i]
df_y              <- Y.data[i]
print(df_x)
# Train MLR
m0                = glmnet(s1_x, s1_y, alpha = num.alpha, lambda = grid, standardize = TRUE)
# Get Best Lambda
m0.min.lambda     = m0$lambda.min
# Fit Best Model
m0.best.fit       = glmnet(s1_x, s1_y, alpha = num.alpha, m0.min.lambda, standardize = TRUE)
# Generate Prediction & Calculate RSE
y_hat             = predict(m0.best.fit, df_x)
m0.rse            = sqrt(sum((df_y - y_hat)^2) / (length(df_y) - 2))
# Append RSE to ridge.rse list
ridge.rse.test[i] = m0.rse
}
for (i in seq(1, length(names.datasets))){
ridge_cv(i, X.datasets, Y.datasets, 0, grid)
}
ridge_cv <- function(i, X.data, Y.data, num.alpha, grid){
# Create DataFrame Objects
df_x              <- X.data[i]
df_y              <- Y.data[i]
print(df_x)
# Train MLR
m0                = glmnet(s1_x, s1_y, alpha = num.alpha, lambda = grid, standardize = TRUE)
# Get Best Lambda
m0.min.lambda     = m0$lambda.min
# Fit Best Model
m0.best.fit       = glmnet(s1_x, s1_y, alpha = num.alpha, m0.min.lambda, standardize = TRUE)
# Generate Prediction & Calculate RSE
y_hat             = predict(m0.best.fit, df_x)
m0.rse            = sqrt(sum((df_y - y_hat)^2) / (length(df_y) - 2))
# Append RSE to ridge.rse list
ridge.rse.test[i] = m0.rse
}
# Define Data Sets (Iterate Datasets)
for (i in seq(1, length(names.datasets))){
ridge_cv(i, X.datasets, Y.datasets, 0, grid)
}
ridge_cv <- function(i, X.data, Y.data, num.alpha, grid){
# Create DataFrame Objects
df_x              <- X.data[i]
df_y              <- Y.data[i]
# Train MLR
m0                = glmnet(df_x, df_y, alpha = num.alpha, lambda = grid, standardize = TRUE)
# Get Best Lambda
m0.min.lambda     = m0$lambda.min
# Fit Best Model
m0.best.fit       = glmnet(df_x, df_y, alpha = num.alpha, m0.min.lambda, standardize = TRUE)
# Generate Prediction & Calculate RSE
y_hat             = predict(m0.best.fit, df_x)
m0.rse            = sqrt(sum((df_y - y_hat)^2) / (length(df_y) - 2))
# Append RSE to ridge.rse list
ridge.rse.test[i] = m0.rse
}
for (i in seq(1, length(names.datasets))){
ridge_cv(i, X.datasets, Y.datasets, 0, grid)
}
ridge_cv <- function(i, X.data, Y.data, num.alpha, grid){
# Create DataFrame Objects
df_x              <- X.data[i]
df_y              <- Y.data[i]
print(df_y)
# Train MLR
m0                = glmnet(df_x, df_y, alpha = num.alpha, lambda = grid, standardize = TRUE)
# Get Best Lambda
m0.min.lambda     = m0$lambda.min
# Fit Best Model
m0.best.fit       = glmnet(df_x, df_y, alpha = num.alpha, m0.min.lambda, standardize = TRUE)
# Generate Prediction & Calculate RSE
y_hat             = predict(m0.best.fit, df_x)
m0.rse            = sqrt(sum((df_y - y_hat)^2) / (length(df_y) - 2))
# Append RSE to ridge.rse list
ridge.rse.test[i] = m0.rse
}
for (i in seq(1, length(names.datasets))){
ridge_cv(i, X.datasets, Y.datasets, 0, grid)
}
t Test RSE
ridge_cv <- function(i, X.data, Y.data, num.alpha, grid){
# Create DataFrame Objects
df_x              <- X.data[i]
df_y              <- Y.data[i]
print(class(df_y))
# Train MLR
m0                = glmnet(df_x, df_y, alpha = num.alpha, lambda = grid, standardize = TRUE)
# Get Best Lambda
m0.min.lambda     = m0$lambda.min
# Fit Best Model
m0.best.fit       = glmnet(df_x, df_y, alpha = num.alpha, m0.min.lambda, standardize = TRUE)
# Generate Prediction & Calculate RSE
y_hat             = predict(m0.best.fit, df_x)
m0.rse            = sqrt(sum((df_y - y_hat)^2) / (length(df_y) - 2))
# Append RSE to ridge.rse list
ridge.rse.test[i] = m0.rse
}
for (i in seq(1, length(names.datasets))){
ridge_cv(i, X.datasets, Y.datasets, 0, grid)
}
print(class(s1_y))
# Define Function Get Test RSE
ridge_cv <- function(i, X.data, Y.data, num.alpha, grid){
# Train MLR
m0                = glmnet(X.data, Y.data, alpha = num.alpha, lambda = grid, standardize = TRUE, nfolds = 10)
# Get Best Lambda
m0.min.lambda     = m0$lambda.min
# Fit Best Model
m0.best.fit       = glmnet(df_x, df_y, alpha = num.alpha, m0.min.lambda, standardize = TRUE)
# Generate Prediction & Calculate RSE
y_hat             = predict(m0.best.fit, df_x)
m0.rse            = sqrt(sum((df_y - y_hat)^2) / (length(df_y) - 2))
# Append RSE to ridge.rse list
ridge.rse.test[i] = m0.rse
}
ridge_cv(s1_x, s1_y, 0, grid)
ridge_cv <- function(X.data, Y.data, num.alpha, grid){
# Train MLR
m0                = glmnet(X.data, Y.data, alpha = num.alpha, lambda = grid, standardize = TRUE, nfolds = 10)
# Get Best Lambda
m0.min.lambda     = m0$lambda.min
# Fit Best Model
m0.best.fit       = glmnet(df_x, df_y, alpha = num.alpha, m0.min.lambda, standardize = TRUE)
# Generate Prediction & Calculate RSE
y_hat             = predict(m0.best.fit, df_x)
m0.rse            = sqrt(sum((df_y - y_hat)^2) / (length(df_y) - 2))
# Append RSE to ridge.rse list
ridge.rse.test[i] = m0.rse
}
ridge_cv(s1_x, s1_y, 0, grid)
# Define Function Get Test RSE
ridge_cv <- function(X.data, Y.data, num.alpha, grid){
# Train MLR
m0                = glmnet(X.data, Y.data, alpha = num.alpha, lambda = grid, standardize = TRUE)
# Get Best Lambda
m0.min.lambda     = m0$lambda.min
# Fit Best Model
m0.best.fit       = glmnet(df_x, df_y, alpha = num.alpha, m0.min.lambda, standardize = TRUE)
# Generate Prediction & Calculate RSE
y_hat             = predict(m0.best.fit, df_x)
m0.rse            = sqrt(sum((df_y - y_hat)^2) / (length(df_y) - 2))
# Append RSE to ridge.rse list
ridge.rse.test[i] = m0.rse
}
ridge_cv(s1_x, s1_y, 0, grid)
ridge_cv <- function(X.data, Y.data, num.alpha, grid){
# Train MLR
m0                = glmnet(X.data, Y.data, alpha = num.alpha, lambda = grid, standardize = TRUE)
# Get Best Lambda
m0.min.lambda     = m0$lambda.min
# Fit Best Model
m0.best.fit       = glmnet(X.data, Y.data, alpha = num.alpha, m0.min.lambda, standardize = TRUE)
# Generate Prediction & Calculate RSE
y_hat             = predict(m0.best.fit, df_x)
m0.rse            = sqrt(sum((df_y - y_hat)^2) / (length(df_y) - 2))
# Append RSE to ridge.rse list
ridge.rse.test[i] = m0.rse
}
ridge_cv(s1_x, s1_y, 0, grid)
ridge_cv <- function(X.data, Y.data, num.alpha, grid){
# Train MLR
m0                = glmnet(X.data, Y.data, alpha = num.alpha, lambda = grid, standardize = TRUE)
# Get Best Lambda
m0.min.lambda     = m0$lambda.min
# Fit Best Model
m0.best.fit       = glmnet(X.data, Y.data, alpha = num.alpha, m0.min.lambda, standardize = TRUE)
# Generate Prediction & Calculate RSE
y_hat             = predict(m0.best.fit, X.data)
m0.rse            = sqrt(sum((Y.data - y_hat)^2) / (length(Y.data) - 2))
# Append RSE to ridge.rse list
ridge.rse.test[i] = m0.rse
}
ridge_cv(s1_x, s1_y, 0, grid)
ridge.rse.test
ridge_cv <- function(X, Y, grid, c_alpha, opt_lambda, c_plot){
# Train Cross Validation Model
m_cv <- cv.glmnet(X, Y, alpha = c_alpha, lambda = grid, standardize = TRUE, nfolds = 10)
# Plot RSE vs Lambda Selection
if(c_plot == TRUE){
plot(m_cv, main = "MLR - 10KFOLD USING RIDGE")
}
# Get Best Lambda
cv_lambda = m_cv$lambda.min
if(opt_lambda == TRUE){
print(paste('Optimal lambda =>', round(cv_lambda, 2)))
}
# Fit Model w/ Best Lambda
m_optimal <- glmnet(X, Y, alpha = c_alpha, lambda = cv_lambda, standardize = TRUE)
y_hat_cv <- predict(m_optimal, X)
model_cv_rse = sqrt(sum((Y - y_hat_cv)^2) / (length(Y) - 2))
return(model_cv_rse)
}
ridge_model = ridge_cv(s4_x, s4_y, grid, c_alpha = 0, opt_lambda = TRUE, c_plot = FALSE)
ridge_model
ridge_cv <- function(X, Y, grid, c_alpha, opt_lambda, c_plot){
# Train Cross Validation Model
m_cv <- cv.glmnet(X, Y, alpha = c_alpha, lambda = grid, standardize = TRUE, nfolds = 10)
# Fit Model w/ Best Lambda
m_optimal <- glmnet(X, Y, alpha = c_alpha, lambda = cv_lambda, standardize = TRUE)
y_hat_cv <- predict(m_optimal, X)
model_cv_rse = sqrt(sum((Y - y_hat_cv)^2) / (length(Y) - 2))
return(model_cv_rse)
}
# Ridge
ridge_model = ridge_cv(s4_x, s4_y, grid, c_alpha = 0, opt_lambda = TRUE, c_plot = FALSE)
ridge_cv <- function(X, Y, grid, c_alpha, opt_lambda, c_plot){
# Train Cross Validation Model
m_cv <- cv.glmnet(X, Y, alpha = c_alpha, lambda = grid, standardize = TRUE, nfolds = 10)
# Plot RSE vs Lambda Selection
if(c_plot == TRUE){
plot(m_cv, main = "MLR - 10KFOLD USING RIDGE")
}
# Get Best Lambda
cv_lambda = m_cv$lambda.min
if(opt_lambda == TRUE){
print(paste('Optimal lambda =>', round(cv_lambda, 2)))
}
# Fit Model w/ Best Lambda
m_optimal <- glmnet(X, Y, alpha = c_alpha, lambda = cv_lambda, standardize = TRUE)
y_hat_cv <- predict(m_optimal, X)
model_cv_rse = sqrt(sum((Y - y_hat_cv)^2) / (length(Y) - 2))
return(model_cv_rse)
}
ridge_model
ridge_cv <- function(X, Y, grid, c_alpha, opt_lambda, c_plot){
# Train Cross Validation Model
m_cv <- cv.glmnet(X, Y, alpha = c_alpha, lambda = grid, standardize = TRUE, nfolds = 10)
# Get Best Lambda
cv_lambda = m_cv$lambda.min
if(opt_lambda == TRUE){
print(paste('Optimal lambda =>', round(cv_lambda, 2)))
}
# Fit Model w/ Best Lambda
m_optimal <- glmnet(X, Y, alpha = c_alpha, lambda = cv_lambda, standardize = TRUE)
y_hat_cv <- predict(m_optimal, X)
model_cv_rse = sqrt(sum((Y - y_hat_cv)^2) / (length(Y) - 2))
return(model_cv_rse)
}
# Ridge
ridge_model = ridge_cv(s4_x, s4_y, grid, c_alpha = 0, opt_lambda = TRUE, c_plot = FALSE)
ridge_model
# Ridge
ridge_model = ridge_cv(s4_x, s4_y, grid, c_alpha = 0, opt_lambda = FALSE, c_plot = FALSE)
ridge_model
print(i)
for (i in X.datasets){
print(i)
}
print(class(i))
for (i in X.datasets){
print(class(i))
}
for (i in seq(1, length(X.datasets))){
m_cv <- cv.glmnet(X.datasets[i], Y.datasets[i], alpha = 0, lambda = grid, standardize = TRUE, nfolds = 10)
}
for (i in seq(1,6)){
m_cv <- cv.glmnet(X.datasets[i], Y.datasets[i], alpha = 0, lambda = grid, standardize = TRUE, nfolds = 10)
}
#m_cv <- cv.glmnet(X.datasets[i], Y.datasets[i], alpha = 0, lambda = grid, standardize = TRUE, nfolds = 10)
print(i)
for (i in seq(1,6)){
#m_cv <- cv.glmnet(X.datasets[i], Y.datasets[i], alpha = 0, lambda = grid, standardize = TRUE, nfolds = 10)
print(i)
}
for (i in seq(1,6)){
print(X.datasets[i])
#m_cv <- cv.glmnet(X.datasets[i], Y.datasets[i], alpha = 0, lambda = grid, standardize = TRUE, nfolds = 10)
}
for (i in seq(1,6)){
print(Y.datasets[i])
#m_cv <- cv.glmnet(X.datasets[i], Y.datasets[i], alpha = 0, lambda = grid, standardize = TRUE, nfolds = 10)
}
for (i in seq(1,6)){
print(Y.datasets[i])
print('@@@@@@@@@@@@@@@@@@')
#m_cv <- cv.glmnet(X.datasets[i], Y.datasets[i], alpha = 0, lambda = grid, standardize = TRUE, nfolds = 10)
}
for (i in seq(1,6)){
cv.glmnet(X.datasets[i], Y.datasets[i], alpha = 0, lambda = grid, standardize = TRUE, nfolds = 10)
}
for (i in seq(1,6)){
cv.glmnet(X.datasets[i], Y.datasets[[i]], alpha = 0, lambda = grid, standardize = TRUE, nfolds = 10)
}
for (i in seq(1,6)){
cv.glmnet(X.datasets[[i]], Y.datasets[[i]], alpha = 0, lambda = grid, standardize = TRUE, nfolds = 10)
}
for (i in seq(1,6)){
cv.glmnet(X.datasets[[i]], Y.datasets[i], alpha = 0, lambda = grid, standardize = TRUE, nfolds = 10)
}
for (i in seq(1,6)){
x = X.datasets[[i]]
y = Y.datasets[i]
#cv.glmnet(X.datasets[[i]], Y.datasets[[i]], alpha = 0, lambda = grid, standardize = TRUE, nfolds = 10)
}
for (i in seq(1,6)){
x = X.datasets[[i]]
y = Y.datasets[i]
print(x)
#cv.glmnet(X.datasets[[i]], Y.datasets[[i]], alpha = 0, lambda = grid, standardize = TRUE, nfolds = 10)
}
print(y)
for (i in seq(1,6)){
x = X.datasets[[i]]
y = Y.datasets[i]
print(y)
#cv.glmnet(X.datasets[[i]], Y.datasets[[i]], alpha = 0, lambda = grid, standardize = TRUE, nfolds = 10)
}
for (i in seq(1,6)){
x = X.datasets[[i]]
y = Y.datasets[i]
cv.glmnet(x, y, alpha = 0, lambda = grid, standardize = TRUE, nfolds = 10)
}
for (i in seq(1,6)){
x = X.datasets[[i]]
y = Y.datasets[i]
print(length(x))
print(length(y))
#cv.glmnet(x, y, alpha = 0, lambda = grid, standardize = TRUE, nfolds = 10)
}
for (i in seq(1,6)){
x = X.datasets[[i]]
y = Y.datasets[[i]]
print(length(x))
print(length(y))
#cv.glmnet(x, y, alpha = 0, lambda = grid, standardize = TRUE, nfolds = 10)
}
ridge.rse.test = c()
list.lambda    = c()
X.datasets     = list(s1_x, s2_x, s3_x, s4_x, s5_x, s6_x)
Y.datasets     = list(s1_y, s2_y, s3_y, s4_y, s5_y, s6_y)
names.datasets = c('s1', 's2', 's3', 's4', 's5', 's6')
for (i in seq(1,6)){
x = X.datasets[[i]]
y = Y.datasets[[i]]
print(length(x))
print(length(y))
#cv.glmnet(x, y, alpha = 0, lambda = grid, standardize = TRUE, nfolds = 10)
}
for (i in seq(1,6)){
x = X.datasets[[i]]
y = Y.datasets[i]
print(length(x))
print(length(y))
#cv.glmnet(x, y, alpha = 0, lambda = grid, standardize = TRUE, nfolds = 10)
}
for (i in seq(1,6)){
x = X.datasets[[i]]
y = Y.datasets[[i]]
print(length(x))
print(length(y))
#cv.glmnet(x, y, alpha = 0, lambda = grid, standardize = TRUE, nfolds = 10)
}
for (i in seq(1,6)){
x = X.datasets[[i]]
y = Y.datasets[[i]]
cv.glmnet(x, y, alpha = 0, lambda = grid, standardize = TRUE, nfolds = 10)
}
for (i in seq(1,6)){
x = X.datasets[[i]]
y = Y.datasets[[i]]
test = cv.glmnet(x, y, alpha = 0, lambda = grid, standardize = TRUE, nfolds = 10)
print(test)
}
for (i in seq(1,6)){
x = X.datasets[[i]]
y = Y.datasets[[i]]
test = cv.glmnet(x, y, alpha = 0, lambda = grid, standardize = TRUE, nfolds = 10)
# Get Best Lambda
cv_lambda = m_cv$lambda.min
# Fit Model w/ Best Lambda
m_optimal <- glmnet(X, Y, alpha = c_alpha, lambda = cv_lambda, standardize = TRUE)
y_hat_cv <- predict(m_optimal, X)
model_cv_rse = sqrt(sum((Y - y_hat_cv)^2) / (length(Y) - 2))
print(model_cv_rse)
}
for (i in seq(1,6)){
# Create Data Objects
X = X.datasets[[i]]
Y = Y.datasets[[i]]
# Train Model Using CV
m_cv = cv.glmnet(X, Y, alpha = 0, lambda = grid, standardize = TRUE, nfolds = 10)
# Get Best Lambda
cv_lambda = m_cv$lambda.min
# Fit Model w/ Best Lambda
m_optimal <- glmnet(X, Y, alpha = c_alpha, lambda = cv_lambda, standardize = TRUE)
y_hat_cv <- predict(m_optimal, X)
model_cv_rse = sqrt(sum((Y - y_hat_cv)^2) / (length(Y) - 2))
print(model_cv_rse)
}
for (i in seq(1,6)){
# Create Data Objects
X = X.datasets[[i]]
Y = Y.datasets[[i]]
# Train Model Using CV
m_cv = cv.glmnet(X, Y, alpha = 0, lambda = grid, standardize = TRUE, nfolds = 10)
# Get Best Lambda
cv_lambda = m_cv$lambda.min
# Fit Model w/ Best Lambda
m_optimal <- glmnet(X, Y, alpha = 0, lambda = cv_lambda, standardize = TRUE)
y_hat_cv <- predict(m_optimal, X)
model_cv_rse = sqrt(sum((Y - y_hat_cv)^2) / (length(Y) - 2))
print(model_cv_rse)
for (i in seq(1,6)){
# Create Data Objects
X = X.datasets[[i]]
Y = Y.datasets[[i]]
# Train Model Using CV
m_cv = cv.glmnet(X, Y, alpha = 0, lambda = grid, standardize = TRUE, nfolds = 10)
# Get Best Lambda
cv_lambda = m_cv$lambda.min
# Fit Model w/ Best Lambda
m_optimal <- glmnet(X, Y, alpha = 0, lambda = cv_lambda, standardize = TRUE)
y_hat_cv <- predict(m_optimal, X)
model_cv_rse = sqrt(sum((Y - y_hat_cv)^2) / (length(Y) - 2))
print(model_cv_rse)
}
print('hello world')
